════════════════════════════════════════   SCREEN 000
( FIRST LOADBLOCK        <10/ 5/83>140) 
                                        
                                        
CREATE R                                
                                        
GET-A&E                                 
                                        
-->                                     
                                        
                                        
                                        
                                        
                                        
                                        
                                        
                                        
                                        
                                        
                                        
                                        
                                        
                                        
                                        
                               ( 13:22) 
════════════════════════════════════════   SCREEN 001
( LOADBLOCK              < 2/ 3/87>141) 
                                        
                                        
                                        
  FORGET R                              
                                        
: R R2-W2 ;                             
                                        
                                        
  142 179 THRU \ write to PRODOS disks  
  180 199 THRU \ PRODOS WORDS           
\ 200 219 THRU \ ProDOS loader          
                                        
                                        
                                        
                                        
                                        
                                        
                                        
                                        
                                        
                                        
                                        
                               ( 13:22) 
════════════════════════════════════════   SCREEN 002
( PRODOS BLK -> TR SEC   < 8/14/86>142) 
EXIT                                    
                                        
Given a prodos blk number n, to find    
the coresponding track/sec use the      
following:                              
                                        
Track is n/8. Use table below to find   
secs in track (blk#)                    
                                        
PRODOS     MVP SEC#                     
BLK mod 8  1st 2nd                      
------------------                      
    0      00  14                       
    1      13  12                       
    2      11  10                       
    3      09  08                       
    4      07  06                       
    5      05  04                       
    6      03  02                       
    7      01  15                       
                                        
                                        
                               ( 13:22) 
════════════════════════════════════════   SCREEN 003
( PRODOS-R/W             < 8/14/86>143) 
                                        
\ Sec #s for prodos block see last scr  
CREATE PTRAN                            
   0 C, 14 C, 13 C, 12 C, 11 C, 10 C,   
   9 C,  8 C,  7 C,  6 C,  5 C,  4 C,   
   3 C,  2 C,  1 C, 15 C,               
                                        
\ vars to avoid stack tricks            
0 CONSTANT PSLT                         
0 CONSTANT PDR                          
0 CONSTANT PTRK                         
0 CONSTANT PR/W                         
                                        
                                        
                                        
                                        
                                        
                                        
                                        
                                        
                                        
                                        
                               ( 13:22) 
════════════════════════════════════════   SCREEN 004
( PRODOS-R/W             < 8/14/86>144) 
\ This routine given a prodos "blk"     
\ number will read or write it from the 
\ disk in slt drv to/from adr           
                                        
\ ** ONLY WORKS WITH 5.25" FLOPPIES **  
: PRODOS-R/W ( ADR BLK SLT DRV R/W -- ) 
  DEPTH 5 < ABORT" 5 ARGS NEEDED"       
  ' PR/W ! ' PDR ! ' PSLT !             
  DUP 280 U< NOT                        
  ABORT" ProDOS BLK# out of range!"     
  \ compute real track/sector for blk#  
  8 /MOD ' PTRK !                       
  \ adr of table entry for relative sec 
  2* PTRAN + >R                         
  \ read/write the first half           
  DUP PSLT PDR R@ C@ PTRK PR/W 1 RWTS   
  \ only read 2nd if no error on 1st    
  DISK-ERROR @ 0=                       
  IF \ read the second half             
   256 + PSLT PDR R> 1+ C@              
   PTRK PR/W 1 RWTS                     
  ELSE R> DDROP \ Clean stack           
  THEN ;                                
════════════════════════════════════════   SCREEN 005
( PDMP                   < 8/14/86>145) 
                                        
\ dumps 512 byte block to screen        
                                        
: PDMP ( ADR -- )                       
  BASE @ >R HEX CR CR                   
  512 0                                 
  DO 8 0                                
   DO DUP J + I + C@                    
    3 .R LOOP                           
   ."  | "                              
   8 0                                  
   DO DUP J + I + C@                    
    DUP 32 - 95 U< NOT                  
    IF DROP 46 THEN                     
    EMIT                                
   LOOP                                 
   ."  |" CR PAUSE ?TERMINAL            
   IF LEAVE THEN                        
  8 +LOOP                               
  R> BASE ! ;                           
                                        
                                        
                                        
════════════════════════════════════════   SCREEN 006
( PD-DRV PD-SLT PDOS-R/W < 1/27/87>146) 
                                        
\ These constants define the slot/drive 
\ where a PRODOS related functions      
\ occur                                 
                                        
6 CONSTANT PD-SLT                       
0 CONSTANT PD-DRV                       
                                        
\ ProDOS r/w that uses above constants  
: PDOS-R/W ( ADR BLK R/W -- )           
  >R PD-SLT PD-DRV R> PRODOS-R/W ;      
                                        
                                        
\ general purpose ProDOS buffer         
\ used as needed                        
                                        
CREATE PD-BUF 512 ALLOT                 
                                        
                                        
                                        
                                        
                                        
                                        
════════════════════════════════════════   SCREEN 007
( @VBITMAP               < 1/29/87>147) 
                                        
0 CONSTANT VBM-BLK \ location of VBM    
0 CONSTANT VBM-ADR \ load address       
0 CONSTANT #BLOCKS \ #blocks in device  
\ read the volume bit map               
: @VBITMAP ( ADR -- )                   
   ' VBM-ADR !                          
   \ read volume directory              
   VBM-ADR 2 1 PDOS-R/W                 
   \ see how many blocks on the device  
   VBM-ADR 41 + @ DUP ' #BLOCKS !       
   4095  > \ VBM must be on 1 block     
   ABORT" Volume has too many blocks"   
   \ find out where bit map starts      
   VBM-ADR 39 + @ ' VBM-BLK !           
   VBM-ADR VBM-BLK 1 PDOS-R/W ;         
                                        
\ store the volume bit map              
: !VBITMAP ( -- )                       
   VBM-ADR VBM-BLK 0 PDOS-R/W ;         
                                        
                                        
                                        
════════════════════════════════════════   SCREEN 008
( @FREE-BLK# -OLD-       < 1/29/87>148) 
EXIT ------ OLD VERSION ------          
\ Will scan ProDOS Volume bit map       
\ and obtain the blk number of the      
\ next open blk                         
                                        
\ -- SCANS BUFFER READ BY @VBITMAP -- / 
                                        
: @FREE-BLK# ( -- N/-1; -1 means none)  
   -1 35 0                              
   DO VBM-ADR I + C@ DUP 0=             
    IF DROP ( all in use )              
    ELSE DDROP I  LEAVE THEN            
   LOOP                                 
   DUP 0> \ was an empty byte found?    
   IF DUP 8 * SWAP VBM-ADR + C@         
    BEGIN DUP 128 <                     
    WHILE SWAP 1+ SWAP 2*               
    REPEAT DROP                         
   THEN ;                               
                                        
                                        
                                        
                               ( 13:22) 
════════════════════════════════════════   SCREEN 009
( @BIT !BIT              < 1/29/87>149) 
                                        
CREATE ^2S                              
  128 C, 64 C, 32 C, 16 C,              
  8 C, 4 C, 2 C, 1 C,                   
                                        
CODE ^BIT ( BIT ADR -- ADR MSK )        
\ >R 8 /MOD R> +                        
\ SWAP ^2S + C@ ;                       
  SEC LDA, # 7 AND,                     
  TAY, ( index to mask )                
  CLC, SEC 1+ ROR, SEC ROR,             
  CLC, SEC 1+ ROR, SEC ROR,             
  CLC, SEC 1+ ROR, SEC ROR,             
  CLC, BOT LDA, SEC ADC, SEC STA,       
  BOT 1+ LDA, SEC 1+ ADC, SEC 1+ STA,   
  ^2S ,Y LDA, BOT STA,                  
  # 0 LDA, BOT 1+ STA,                  
  NEXT JMP,                             
C;                                      
                                        
                                        
                                        
                               ( 13:22) 
════════════════════════════════════════   SCREEN 010
( @BIT !BIT              < 1/29/87>150) 
                                        
\ read a bit from an array starting     
\ at address 7 is bit num 0             
: @BIT ( BIT ADR -- )                   
  ^BIT SWAP C@ AND 0= NOT ;             
                                        
\ store bit value to array              
: !BIT ( VAL BIT ADR -- )               
  ^BIT ROT                              
  IF OVER C@ OR SWAP C!                 
  ELSE 255 XOR                          
    OVER C@ AND SWAP C!                 
  THEN ;                                
                                        
                                        
                                        
                                        
                                        
                                        
                                        
                                        
                                        
                               ( 13:22) 
════════════════════════════════════════   SCREEN 011
( @FREE-BLK#             < 1/29/87>151) 
                                        
\ -- SCANS BUFFER READ BY @VBITMAP -- / 
                                        
\ Will scan ProDOS Volume bit map       
\ and obtain the blk number of the      
\ next open blk                         
: @FREE-BLK# ( -- N/-1; -1 means none)  
  -1 #BLOCKS 0                          
  DO I VBM-ADR @BIT                     
   IF DROP I LEAVE THEN                 
  LOOP ;                                
                                        
\ return # blocks available on drive    
: #FREE-BLKS ( -- N )                   
  0 #BLOCKS 0                           
  DO I VBM-ADR @BIT +                   
  LOOP ;                                
                                        
\ mark block# as used in buffer         
: !USED ( BLK# -- )                     
  0 SWAP VBM-ADR !BIT ;                 
                                        
                                        
════════════════════════════════════════   SCREEN 012
( .NAME                  < 1/29/87>152) 
                                        
\ # of bytes per directory entry        
0 CONSTANT BYTE/DIR                     
\ # of directory entries per block      
0 CONSTANT DIR/BLK                      
                                        
: .NAME ( ADR -- )                      
   COUNT 15 AND TYPE ;                  
                                        
: .TYPE ( ADR -- )                      
   DUP 16 + C@ DUP 255 =                
   IF ."  SYS" ELSE DUP 252 =           
    IF ."  BAS" ELSE DUP 6 =            
     IF ."  BIN" ELSE DUP 4 .R          
   THEN THEN THEN DROP ;                
                                        
: .CATNAME ( ADR -- )                   
   .TYPE BASE @ >R HEX                  
   DUP 21 + @ 5 .R                      
   DUP 31 + @ 5 U.R SPACE               
   R> BASE ! .NAME ;                    
                                        
                                        
════════════════════════════════════════   SCREEN 013
( FCB# ^FCB +FCB         < 1/29/87>153) 
                                        
VARIABLE FCB# \ index to cur blk        
VARIABLE LBLK# \ last block # read      
                                        
: @PBLK ( N -- ; read into PD-BUF )     
   DUP LBLK# !                          
   PD-BUF SWAP 1 PDOS-R/W ;             
                                        
: !PBLK ( -- ; store PD-BUF )           
   PD-BUF LBLK# @ 0 PDOS-R/W ;          
                                        
\ return address in RAM of cur FCB      
: ^FCB ( -- OFS )                       
   FCB# @ BYTE/DIR * 4 + PD-BUF + ;     
                                        
: +FCB ( -- T/F; T=no more left )       
   1 FCB# +! FCB# @ DIR/BLK >           
   IF PD-BUF 2+ @ ?DUP \ more dir blks? 
    IF @PBLK 0 FCB# !                   
    ELSE 1 THEN                         
   ELSE 0 THEN ;                        
                                        
                                        
════════════════════════════════════════   SCREEN 014
( <CAT>                  < 1/29/87>154) 
                                        
\ assumes PD-BUF contains the first     
\ direcotory block (could be first      
\ block of subdir as well)              
\ it will then list N files/dirs        
                                        
: <CAT> ( N -- ; n=# files to list )    
  1 FCB# ! ( skip over volume header )  
  BEGIN DUP 0> \ files left?            
  WHILE \ compute address in buffer     
   ^FCB DUP C@ \ not deleted?           
   IF .CATNAME CR 1-                    
   ELSE DROP THEN                       
   +FCB ABORT" <CAT> error"             
  REPEAT                                
  DROP ;                                
                                        
                                        
                                        
                                        
                                        
                                        
                               ( 13:22) 
════════════════════════════════════════   SCREEN 015
( SET-INFO               < 1/29/87>155) 
                                        
\ reads the volume directory            
\ and sets appropriate constants        
                                        
: SET-INFO ( -- )                       
  2 @PBLK \ get vol direc               
  PD-BUF 35 + C@ ' BYTE/DIR !           
  PD-BUF 36 + C@ ' DIR/BLK !            
;                                       
                                        
                                        
                                        
                                        
                                        
                                        
                                        
                                        
                                        
                                        
                                        
                                        
                                        
                               ( 13:22) 
════════════════════════════════════════   SCREEN 016
( CAT                    < 1/29/87>156) 
                                        
: CAT                                   
  SET-INFO                              
  \ print header                        
  CR CR ." Volume: "                    
  PD-BUF 4 + .NAME CR CR                
  \ scan files                          
  PD-BUF 37 + @ ( # files ) ?DUP        
  IF ." TYP LEN  AUX  NAME" CR          
   30 0 DO 45 EMIT LOOP CR              
   <CAT>                                
  ELSE ." No files" CR CR               
  THEN                                  
  CR CR                                 
;                                       
                                        
                                        
                                        
                                        
                                        
                                        
                                        
                                        
════════════════════════════════════════   SCREEN 017
( @FREE-FCB              < 1/29/87>157) 
                                        
\ looks for an empty FCB to store a new 
\ file name in returns true if one is   
\ found will not expand directory       
\ (leaves dir block in PD-BUF and       
\  FCB# pointing to entry)              
                                        
: @FREE-FCB ( - T/F; T=empty FCB found) 
  SET-INFO 1 FCB# ! \ read 1st dir blk  
  BEGIN ^FCB C@ 0= NOT                  
  WHILE +FCB                            
   IF 0 EXIT THEN                       
  REPEAT                                
  \ ^FCB points to valid                
  1                                     
;                                       
                                        
                                        
                                        
                                        
                                        
                                        
                               ( 13:22) 
════════════════════════════════════════   SCREEN 018
( PIND @PIND !PIND       < 1/29/87>158) 
                                        
CREATE PIND 512 ALLOT                   
VARIABLE PIND-BLK                       
                                        
CODE @PIND ( N -- V )                   
  BOT LDY,                              
  PIND ,Y LDA, BOT STA,                 
  PIND 256 + ,Y LDA,                    
  BOT 1+ STA,                           
  NEXT JMP, C;                          
                                        
CODE !PIND ( V N -- )                   
  BOT LDY,                              
  SEC LDA, PIND ,Y STA,                 
  SEC 1+ LDA,                           
  PIND 256 + ,Y STA,                    
  POPTWO JMP, C;                        
                                        
: SETPIND ( -- N )                      
   PIND 512 0 FILL                      
   @FREE-BLK# DUP PIND-BLK !            
   DUP !USED ;                          
                               ( 13:22) 
════════════════════════════════════════   SCREEN 019
( !FILE                  < 1/30/87>159) 
                                        
CREATE FCB 50 ALLOT                     
VARIABLE BSA   \ address                
VARIABLE BSL   \ length                 
VARIABLE BSN   \ #blocks used by        
VARIABLE BSAUX \ Aux field contents     
VARIABLE BSB#  \ current block #        
                                        
\ find empty block, write it, update    
\ RAM volume bit map, inc pointer       
: !BLK ( ADR -- ; find and store BLK )  
   @FREE-BLK# DUP !USED                 
   DUP BSB# @ !PIND                     
   0 PDOS-R/W 1 BSB# +! ;               
                                        
\ write memory image to disk            
: !FILE ( -- )                          
   0 BSB# !                             
   BEGIN BSL @ 0>                       
   WHILE BSA @ !BLK                     
    512 BSA +! -512 BSL +!              
   REPEAT ;                             
                               ( 13:22) 
════════════════════════════════════════   SCREEN 020
( MACK-FCB               <10/ 5/83>160) 
                                        
\ create a FCB with name at ADR         
\ and the type code passed              
: MAKE-FCB ( ADR TYP -- )               
   >R FCB 50 0 FILL    \ zero fcb       
   FCB OVER C@ 1+ CMOVE \ move in name  
   FCB C@ 32 OR FCB C! \ make sapling   
   R> FCB 16 + C!      \ BIN file type  
   SETPIND FCB 17 + !  \ KEY_POINTER    
   BSN @   FCB 19 + !  \ BLOCKS_USED    
   BSL @   FCB 21 + !  \ EOF            
   0       FCB 23 + C! \ EOF byte 3     
   195     FCB 30 + C! \ ACCESS         
   BSAUX @ FCB 31 + !  \ AUX_TYPE       
   2       FCB 37 + !  \ HEADER_POINTER 
;                                       
                                        
                                        
                                        
                                        
                                        
                                        
                                        
════════════════════════════════════════   SCREEN 021
( CLOSE-FILE             < 1/29/87>161) 
                                        
\ finish writing the file               
\ update directory, write FCB           
: CLOSE-FILE ( -- )                     
   @FREE-FCB NOT                        
   ABORT" CLOSE error"                  
   \ Copy in new FCB                    
   FCB ^FCB BYTE/DIR CMOVE              
   LBLK# @ 2 = \ inc file count         
   IF 1 PD-BUF 37 + +! THEN             
   !PBLK \ write out directory block    
   LBLK# @ 2 = NOT                      
   IF 2 @PBLK \  get volume dir         
     1 PD-BUF 37 + +!                   
     !PBLK THEN                         
   \ write out index block              
   PIND PIND-BLK @ 0 PDOS-R/W           
   \ write volume bit map               
   !VBITMAP                             
;                                       
                                        
                                        
                                        
════════════════════════════════════════   SCREEN 022
( BSAVE                  < 1/30/87>162) 
\ see if room for file BSL bytes        
: ?CANMAKE ( -- ; checks some things)   
   @FREE-FCB 0=                         
   ABORT" No FCB's available"           
   FIRST 530 - @VBITMAP                 
   BSL @ 0 512 U/MOD SWAP 0= NOT + 1+   
   DUP BSN ! #FREE-BLKS >               
   ABORT" No room on disk" ;            
                                        
: <BSAVE> ( ADR LEN AUX -- )            
   BL WORD >R DEPTH 3 <                 
   R@ C@ 0= OR R@ C@ 15 > OR            
   ABORT" use: adr len ladr BSAVE name" 
   BSAUX ! BSL ! BSA ! ?CANMAKE         
   R> 6 MAKE-FCB \ set up BIN FCB       
   !FILE CLOSE-FILE ;                   
                                        
: BSAVE ( ADR LEN -- )                  
   OVER <BSAVE> ;                       
                                        
                                        
                                        
                                        
════════════════════════════════════════   SCREEN 023
( PSAVE                  < 1/29/87>163) 
                                        
\ save current forth image              
\ so that it will load under            
\ prodos file system                    
\ use: PSAVE name                       
: PSAVE                                 
   LIMIT >R 37370 ' LIMIT !             
   FORGET-SYS                           
   [COMPILE] FORTH DEFINITIONS FREEZE   
   2048 HERE 2000 - BSAVE               
   R> ' LIMIT ! ;                       
                                        
EXIT                                    
: START                                 
   RM-W2 <ABORT> ;                      
' START CFA ' ABORT !                   
                                        
EXIT ----                               
                                        
  38300 is 100 bytes below              
  where the basic interpreter           
  starts                                
                                        
════════════════════════════════════════   SCREEN 025
( >FILE                  < 1/30/87>165) 
                                        
VARIABLE TFS \ start block number       
VARIABLE TFE \ end block number         
                                        
\ copy screens to the file              
: >FILE ( -- )                          
   0 BSB# !                             
   BEGIN TFS @ TFE @ > NOT              
   WHILE                                
    TFS @ BLOCK DUP !BLK 512 + !BLK     
    1 TFS +!                            
   REPEAT                               
;                                       
                                        
                                        
                                        
                                        
                                        
                                        
                                        
                                        
                                        
                                        
════════════════════════════════════════   SCREEN 026
( TOFILE                 < 1/30/87>166) 
                                        
\ use: S E TOFILE name                  
\ creates a file "name" which           
\ will contain block S to E             
                                        
: TOFILE ( S E -- )                     
   BL WORD >R DEPTH 2 <                 
   R@ C@ 0= OR R@ C@ 15 > OR            
   ABORT" use: s e TOFILE name"         
   DDUP > ABORT" wrong order"           
   TFE ! TFS !                          
   0 BSAUX ! \ aux field unused         
   TFE @ TFS @ - 1+ 1024 * BSL ! \ len  
   ?CANMAKE                             
   R> 248 MAKE-FCB \ set up $F1 FCB     
   >FILE CLOSE-FILE ;                   
                                        
                                        
                                        
                                        
                                        
                                        
                                        
════════════════════════════════════════   SCREEN 040
( MLI NOTES              < 2/ 2/87>180) 
EXIT _________________________________  
                                        
MLI is the interface word between       
forth and ProDOS. MLI takes two args,   
the address of the parameter table      
and the command number. These values    
are planted into <MLI> and then ProDOS  
is called.                              
                                        
There are two versions of the MLI       
caller, developement and runtime.       
                                        
The developement version switchs to     
the main ZP/BSM, makes the call, then   
switches back to the aux ZP/BSM         
where the appendix is kept              
                                        
The runtime version simply makes        
call to ProDOS as the kernel is not     
present.                                
                                        
                                        
                               ( 13:22) 
════════════════════════════════════════   SCREEN 041
( MORE MLI NOTES         < 2/ 2/87>181) 
EXIT _________________________________  
                                        
                                        
                                        
                                        
                                        
                                        
                                        
                                        
                                        
                                        
                                        
                                        
                                        
                                        
                                        
                                        
                                        
                                        
                                        
                                        
                                        
                                        
════════════════════════════════════════   SCREEN 042
( <MLI>                  < 2/ 2/87>182) 
                                        
VARIABLE MLI-ERR                        
                                        
\ call MLI (values already stored)      
\ put return code in A and in MLI-ERR   
HEX CODE {MLI}                          
   BF00 JSR,                            
   0 C,        \ command number         
   0 ,         \ address                
   CS NOT IF,  \ no error make sure     
    # 0 LDA,   \ accum is zero          
   THEN,                                
   MLI-ERR STA,                         
   RTS, C;                              
DECIMAL                                 
                                        
                                        
                                        
                                        
                                        
                                        
                                        
                               ( 13:22) 
════════════════════════════════════════   SCREEN 043
( <DMLI>                 < 2/ 2/87>183) 
EXIT --- NOT USED IN THIS VERSION ---   
\ Developement version of MLI           
VARIABLE ASP \ save old stack pointer   
HEX CODE <DMLI> ( ADR CMD# -- ERR/0 )   
   \ move parameters to word            
   BOT LDA, ' {MLI} 3 + STA,            
   SEC LDA, ' {MLI} 4 + STA,            
   SEC 1+ LDA, ' {MLI} 5 + STA,         
   \ save state, swith to main call     
   SEI, XSAVE STX,   \ save data "SP"   
   TSX, ASP STX,     \ save aux SP      
   # FF LDX, TXS,    \ reset stack      
   C008 STA,         \ main BSM,ZP      
   CLI, ' <MLI> JSR, \ do the command   
   SEI, C009 STA,    \ aux BSM,ZP       
   ASP LDX, TXS,     \ restore stack    
   XSAVE LDX,        \ & data stack     
   SEC STA,          \ return error     
   # 0 LDA, SEC 1+ STA,                 
   POP JMP, C;                          
DECIMAL                                 
                                        
                                        
════════════════════════════════════════   SCREEN 044
( <RMLI>                 < 2/ 2/87>184) 
                                        
\ runtime version of MLI                
                                        
HEX CODE <RMLI> ( ADR CMD# -- ERR/0 )   
   \ move parameters to word            
   BOT LDA, ' {MLI} 3 + STA,            
   SEC LDA, ' {MLI} 4 + STA,            
   SEC 1+ LDA, ' {MLI} 5 + STA,         
   \ call prodos                        
   ' {MLI} JSR,                         
   \ save return code                   
   SEC STA,       \ return code         
   # 0 LDA, SEC 1+ STA, \               
   POP JMP,                             
C; DECIMAL                              
                                        
                                        
                                        
                                        
                                        
                                        
                                        
                               ( 13:22) 
════════════════════════════════════════   SCREEN 045
( MLI DMLI SMLI          <10/ 5/83>185) 
                                        
CREATE MPARAMS 20 ALLOT                 
                                        
CODE <MLI> ( PARAM-ADR CMD# -- ERR/0)   
  ' <RMLI> JMP, C;                      
                                        
: MLI ( CMD# -- ; aborts if error )     
  MPARAMS SWAP <MLI> ( error? )         
  IF 49233 C@ DROP CR CR                
   ." MLI ERROR # $" MLI-ERR C@         
   HEX . DECIMAL CR CR <ABORT>          
  THEN ;                                
                                        
: ]MP ( N -- ADR ) MPARAMS + ;          
: #PARAMS 0 ]MP ;                       
                                        
EXIT ------                             
: DMLI ( -- ; set DMLI )                
   ' <DMLI> ' <MLI> 1+ ! ;              
: RMLI ( -- ; set RMLI )                
   ' <RMLI> ' <MLI> 1+ ! ;              
                                        
                               ( 13:22) 
════════════════════════════════════════   SCREEN 046
( FILE# $ GET-NAME       <10/ 5/83>186) 
                                        
HEX                                     
 9200 CONSTANT FILEBUF                  
    0 CONSTANT FILE#                    
DECIMAL                                 
                                        
: $ ( -- )                              
  BL WORD BASE @ >R HEX                 
  NUMBER DROP R> BASE !                 
  [COMPILE] LITERAL                     
; IMMEDIATE                             
                                        
: GET-NAME ( -- ADR )                   
  BL WORD DUP C@ 0= OVER C@ 15 > OR     
  ABORT" BAD FILE NAME" ;               
                                        
                                        
                                        
                                        
                                        
                                        
                                        
                                        
════════════════════════════════════════   SCREEN 047
( CLOSE OPEN             <10/ 5/83>187) 
                                        
: <CLOSE> ( N -- )                      
   1 #PARAMS C!                         
   ( N ) 1 ]MP C!                       
   $ CC MLI ;                           
                                        
: CLOSE ( -- )                          
   FILE# ?DUP \ if file is open         
   IF <CLOSE> 0 ' FILE# ! THEN ;        
                                        
\ open file name at address use         
\ FBUF as the file buffer address       
: <OPEN> ( ADR FBUF -- )                
   ?2NUM ( FILE BUF ) 3 ]MP !           
   ( FILE NAME ) 1 ]MP !                
   3 #PARAMS C! $ C8 MLI ( OPEN )       
   5 ]MP C@ ' FILE# ! ;                 
                                        
\ use: OPEN name                        
: OPEN                                  
   CLOSE GET-NAME FILEBUF <OPEN> ;      
                                        
                               ( 13:22) 
════════════════════════════════════════   SCREEN 048
( FFLUSH OPEN-NEW        <10/ 5/83>188) 
                                        
\ Write out the current file            
: FFLUSH ( -- )                         
   1 #PARAMS C!                         
   FILE# 1 ]MP C!                       
   $ CD MLI ;                           
                                        
: OPEN-NEW ( -- )                       
   GET-NAME 1 ]MP ! CLOSE               
   7 #PARAMS C!                         
   $ C3 3 ]MP C!  \ ACCESS CODE         
   $ F8 4 ]MP C!  \ FILE TYPE           
   0 5 ]MP !      \ AUX_TYPE            
   1 7 ]MP C!     \ STORAGE TYPE        
   0 8 ]MP !      \ DATE                
   0 10 ]MP !     \ TIME                
   $ C0 MLI       ( CREATE )            
   1 ]MP @ FILEBUF <OPEN>               
   FFLUSH ;                             
                                        
                                        
                                        
                               ( 13:22) 
════════════════════════════════════════   SCREEN 049
( ?FILE-OPEN SCREENS     <10/ 5/83>189) 
                                        
: ?FILE-OPEN                            
   FILE# 0= ABORT" NO FILE OPENED" ;    
                                        
: SCREENS ( N -- )                      
   ?NUM ?FILE-OPEN                      
   4 * 3 ]MP !                          
   0 2 ]MP C!                           
   FILE# 1 ]MP C!                       
   2 #PARAMS C!                         
   $ D0 MLI                             
   FFLUSH ;                             
                                        
                                        
                                        
                                        
                                        
                                        
                                        
                                        
                                        
                                        
                                        
════════════════════════════════════════   SCREEN 050
( <DOS-R/W>              <10/ 5/83>190) 
                                        
: <DOS-R/W> ( ADR BLK R/W -- )          
   ?FILE-OPEN                           
    \ position at proper location       
   >R ( BLK# ) 4 * 3 ]MP ! 0 2 ]MP C!   
   FILE# 1 ]MP C! 2 #PARAMS C!          
   $ CE MLI ( SET_MARK )                
    \ now read/write the block          
   4 #PARAMS C!                         
   FILE# 1 ]MP C!                       
   ( ADR ) 2 ]MP !                      
   1024 4 ]MP ! R>                      
   IF $ CA ( READ )                     
   ELSE $ CB ( WRITE ) THEN             
   MLI ;                                
                                        
: DOS-R/W                               
   ' <DOS-R/W> CFA ' R/W !              
;                                       
                                        
                                        
                                        
                               ( 13:22) 
════════════════════════════════════════   SCREEN 051
( <FILE-LEN> FILE.       <10/ 5/83>191) 
                                        
                                        
: <FILE-LEN> ( N -- D ; D is #of bytes) 
   ?NUM 2 #PARAMS C!                    
   ( N ) 1 ]MP C!                       
   $ D1 MLI                             
   2 ]MP @                              
   4 ]MP C@ ;                           
                                        
: FILE.                                 
   CR FILE# ?DUP                        
   IF <FILE-LEN>                        
    ." Files is " DDUP D.               
    ." bytes (" 1024 U/MOD              
    0 .R IF 43 EMIT THEN                
    ."  blocks)"                        
   ELSE ." No file opened"              
   THEN CR                              
;                                       
                                        
                                        
                                        
                               ( 13:22) 
════════════════════════════════════════   SCREEN 052
( PREFIX                 <10/ 5/83>192) 
                                        
: <!PREFIX> \ ADR --                    
  1 #PARAMS C! ( ADR ) 1 ]MP !          
  $ C6 MLI ;                            
                                        
: <@PREFIX> \ ADR --                    
  1 #PARAMS C! ( ADR ) 1 ]MP !          
  $ C7 MLI ;                            
                                        
\ USE: to set: PREFIX name              
\ USE: to read: PREFIX                  
: PREFIX                                
  BL WORD DUP C@ 0=                     
  IF DROP CR ." PREFIX = "              
   PAD <@PREFIX> PAD C@                 
   IF PAD COUNT TYPE                    
   ELSE ." <NONE>"                      
   THEN                                 
  ELSE <!PREFIX>                        
  THEN                                  
;                                       
                                        
                               ( 13:22) 
════════════════════════════════════════   SCREEN 053
( BYE                    <10/ 5/83>193) 
                                        
: BYE                                   
   \ close all the files                
   1 $ BF94 C!                          
   1 #PARAMS C!                         
   0 1 ]MP C! \ file# 0=close all       
   $ CC MLI                             
   \ now call the selector              
   4 #PARAMS C!                         
   0 1 ]MP ! 0 3 ]MP !                  
   0 5 ]MP !                            
   $ 65 MLI                             
;                                       
                                        
                                        
                                        
                                        
                                        
                                        
                                        
                                        
                                        
                                        
════════════════════════════════════════   SCREEN 060
( PRODOS LOADER NOTES    < 2/ 3/87>200) 
--> --> --> --> --> --> --> --> --> --> 
                                        
The ProDOS forth loader consists of     
a short program that is responsible     
for loading the forth system from       
three files:                            
                                        
NAME.KER  Runtime $800-$1FFF            
NAME.AUX  Runtime $4000-$BEFF           
NAME.APP  Appendix $D000-$FFFF          
                                        
Loader follows the auto-run protocol    
described in "Apple ProDOS" by Gary     
Little on page 141. The auto-run name   
(NAME) is used as the base name         
to which the extensions are attached    
                                        
                                        
                                        
                                        
                                        
                                        
                               ( 13:22) 
════════════════════════════════════════   SCREEN 061
( PRODOS LOADER NOTES    < 2/ 3/87>201) 
--> --> --> --> --> --> --> --> --> --> 
                                        
The first thing the loader does is to   
move itself to $BD00. Next it sets the  
prefix to the value at $280 (which was  
placed there by the selector)           
                                        
It then looks for the file NAME.KER,    
If it is found the entire file is       
loaded at the address specified in      
the AUX_TYPE field, otherwise an error  
occurs.                                 
                                        
Next the entire file NAME.AUX is loaded 
at the address in AUX_TYPE.  No error   
occurs if this file is missing.         
                                        
-->                                     
                                        
                                        
                                        
                                        
                               ( 13:22) 
════════════════════════════════════════   SCREEN 062
( PRODOS LOADER NOTES    < 2/ 3/87>202) 
--> --> --> --> --> --> --> --> --> --> 
                                        
Lastly the file NAME.APP is loaded into 
bank1 of the auxillary BSM at $D000.    
                                        
When loading the files the file buffer  
is positioned at $B900.                 
                                        
When loading the appendix the file is   
read 1K at a time to a buffer starting  
at $B500 and then transfered to the     
auxillary BSM.                          
                                        
This means that the forth kernel must   
never extend past $B500 or it will      
get clobbered while loading. This is    
still better than the standalone MVP    
in which LIMIT is at $B600 and you      
may reuse the 2K for file buffers       
once the system is loaded.              
                                        
                                        
                               ( 13:22) 
════════════════════════════════════════   SCREEN 063
( PRODOS LOADER NOTES    < 2/ 3/87>203) 
--> --> --> --> --> --> --> --> --> --> 
                                        
                                        
                                        
                                        
                                        
                                        
                                        
                                        
                                        
                                        
                                        
                                        
                                        
                                        
                                        
                                        
                                        
                                        
                                        
                                        
                                        
                               ( 13:22) 
════════════════════════════════════════   SCREEN 064
( PRODOS VARIABLES       < 2/ 3/87>204) 
                                        
CREATE LOADER \ marker                  
                                        
                                        
HEX                                     
\ zero page data areas                  
  D0 CONSTANT PTR    \ zero page ptr    
                                        
\ ProDOS locations                      
                                        
                                        
DECIMAL                                 
                                        
-->                                     
                                        
                                        
                                        
                                        
                                        
                                        
                                        
                                        
                               ( 13:22) 
════════════════════════════════════════   SCREEN 065
( LABEL WORDS            < 2/ 3/87>205) 
   0 CONSTANT LOAD-ADR                  
8192 CONSTANT RUN-ADR                   
                                        
: ADJADR ( ADR -- ADR' )                
  LOAD-ADR - RUN-ADR + ;                
                                        
: LABEL: ( -- )                         
  [COMPILE] '                           
  HERE ADJADR SWAP ! ;                  
                                        
: L: \ create a label                   
  CREATE 0 ,                            
  DOES> @ ?DUP 0=                       
   ABORT" LABEL NOT SET" ;              
                                        
                                        
: LO# 255 AND ;                         
: HI# 0 256 U/MOD SWAP DROP ;           
: " ( -- ) 34 WORD C@ 1+ ALLOT ;        
                                        
-->                                     
                                        
                               ( 13:22) 
════════════════════════════════════════   SCREEN 066
( LABELS                 < 2/ 3/87>206) 
                                        
  L: LOAD-ERR     L: MBUF               
  L: REF#         L: FLEN               
  L: FAUX                               
  L: COUT1        L: CTYPE              
  L: CRLF                               
  L: PRNIB        L: PRHEX              
  L: DIE          L: READ               
                                        
: ]MBUF ( N -- ) MBUF + ;               
                                        
HEX                                     
: CALL-MLI ( N -- )                     
  ?NUM 20 C, 00 C, BF C, \ BF00 JSR,    
  ( n ) C, MBUF , ;                     
                                        
DECIMAL -->                             
                                        
                                        
                                        
                                        
                                        
                               ( 13:22) 
════════════════════════════════════════   SCREEN 067
( PLOADER                < 2/ 3/87>207) 
                                        
HEX CREATE PLOADER                      
  GET-A&E ASSEMBLER MEM !CSP            
  HERE ' LOAD-ADR !                     
  HERE ' RUN-ADR !  \ develope only     
  0000 JMP,   \ patched later           
  EE C, EE C, \ indentification bytes   
  41 C,       \ buffer length           
  HERE                                  
  " FORTH.KER" \ file to be loaded      
  41 + DP !   \ allocate hole           
DECIMAL                                 
                                        
\ --- strings ---                       
  LABEL: LOAD-ERR                       
    " UNABLE TO LOAD, ERR -- $"         
                                        
                                        
-->                                     
                                        
                                        
                                        
                               ( 13:22) 
════════════════════════════════════════   SCREEN 068
( PLOADER                < 2/ 3/87>208) 
                                        
\ ---- TABLES/VARIABLES ----            
                                        
\ This buffer is used to communicate    
\ with the MLI routine. It is filled    
\ with the proper parameters            
                                        
LABEL: MBUF \ Parameter table for       
  20 ALLOT  \ MLI calls                 
                                        
LABEL: REF# 0 C, \ file reference #     
LABEL: FLEN 0 C, \ len of file (bytes)  
LABEL: FAUX 0 ,  \ Aux code for file    
                                        
-->                                     
                                        
                                        
                                        
                                        
                                        
                                        
                                        
                               ( 13:22) 
════════════════════════════════════════   SCREEN 069
( PLOADER                < 2/ 3/87>209) 
                                        
\ Routines                              
\ All routines that call the monitor    
\ switch it in CALL, then back to bank1 
                                        
HEX LABEL: COUT1                        
  PHA, C082 LDA,    \ Switch in ROM     
  PLA, # 80 ORA,    \ set hi bit        
  FDF0 JSR,         \ Call COUT1        
  C083 LDA,         \ switch to RAM     
  C083 LDA,         \ bank 1            
  RTS,                                  
DECIMAL                                 
                                        
LABEL: CTYPE    \ at pointed by PTR     
  # 0 LDY, PTR )Y LDA, TAX, INY,        
  BEGIN, PTR )Y LDA,                    
   COUT1 JSR,                           
   INY, DEX, 0=                         
  UNTIL,                                
  RTS,                                  
                                        
-->                            ( 13:22) 
════════════════════════════════════════   SCREEN 070
( PLOADER                < 2/ 3/87>210) 
                                        
\ Routines cont.                        
                                        
LABEL: CRLF                             
   # 13 LDA, COUT1 JSR,                 
   # 10 LDA, COUT1 JMP,                 
                                        
LABEL: PRNIB                            
   # 15 AND, # 48 ORA,                  
   # 58 CMP, 0< NOT                     
   IF, CLC, # 7 ADC, THEN,              
   COUT1 JMP,                           
                                        
LABEL: PRHEX                            
   PHA, CLC, .A ROR, .A ROR,            
   .A ROR, .A ROR, PRNIB JSR,           
   PLA, PRNIB JMP,                      
                                        
-->                                     
                                        
                                        
                                        
                               ( 13:22) 
════════════════════════════════════════   SCREEN 071
(                        < 2/ 3/87>211) 
\ A=ProDOS error, X=Area iden byte      
LABEL: DIE                              
   PHA, TXA, PHA,                       
   CRLF JSR, CRLF JSR,                  
   # LOAD-ERR LO# LDA, PTR STA,         
   # LOAD-ERR HI# LDA, PTR 1+ STA,      
   CTYPE JSR,                           
   PLA, PRHEX JSR, PLA, PRHEX JSR,      
   CRLF JSR, CRLF JMP,                  
   BEGIN, AGAIN, \ infinite loop        
                                        
LABEL: READ HEX                         
   0CA CALL-MLI                         
   CS IF, # 0 LDX, DIE JSR, THEN,       
   \ read/requested len MUST match      
   # 0 LDX,                             
   4 ]MBUF LDA, 6 ]MBUF CMP, 0=         
   IF, 5 ]MBUF LDA, 7 ]MBUF CMP, THEN,  
   0= NOT \ my error code               
   IF, # 0 LDX, # FF LDA, DIE JSR,      
   THEN,                                
DECIMAL -->                             
                               ( 13:22) 
════════════════════════════════════════   SCREEN 072
(                        < 2/ 3/87>212) 
                                        
HEX                                     
\ JMP at 2000 branches here             
   HERE ADJADR PLOADER 1+ !             
                                        
\ Initialize STACK                      
   # 0FF LDX, TXS,                      
                                        
\ Make sure prefix points to where      
\ the loader program was found          
   #  1 LDA, 0 ]MBUF STA,               
    \ use name set by SELECTOR          
   #  2 LDA, 1 ]MBUF STA,               
   # 80 LDA, 2 ]MBUF STA,               
   0C6 CALL-MLI  ( SET_PREFIX )         
   CS IF, # 1 LDX, DIE JSR, THEN,       
                                        
DECIMAL -->                             
                                        
                                        
                                        
                                        
                               ( 13:22) 
════════════════════════════════════════   SCREEN 073
(                        < 2/ 3/87>213) 
                                        
HEX                                     
\ Now try to find the load file         
    # 0A LDA, 0 ]MBUF STA,              
     \ Name in autorun buffer           
    # 06 LDA, 1 ]MBUF STA,              
    # 20 LDA, 2 ]MBUF STA,              
    0C4 CALL-MLI ( GET_FILE_INFO )      
    CS IF, # 2 LDX, DIE JSR, THEN,      
     \ Check the file type code         
    4 ]MBUF LDA,                        
    0F1 CMP, 0= NOT                     
    IF, # 3 LDX, DIE JSR, THEN,         
     \ save aux code which is the       
     \ load address for the 2nd part    
     \ of the kernel                    
    5 ]MBUF LDA, FAUX STA,              
    6 ]MBUF LDA, FAUX 1+ STA,           
                                        
                                        
DECIMAL -->                             
                                        
                               ( 13:22) 
════════════════════════════════════════   SCREEN 074
(                        < 2/ 3/87>214) 
HEX                                     
\ Now lets open the file for real       
    # 3 LDA, 0 ]MBUF STA,               
     \ Name in autorun buffer           
    # 06 LDA, 1 ]MBUF STA,              
    # 20 LDA, 2 ]MBUF STA,              
     \ use $2100 as file buffer         
    # 00 LDA, 3 ]MBUF STA,              
    # 21 LDA, 4 ]MBUF STA,              
    0C8 CALL-MLI     ( OPEN )           
    CS IF, # 4 LDX, DIE JSR, THEN,      
    5 ]MBUF LDA, REF# STA,              
\ find file length                      
    1 ]MBUF STA,                        
    # 2 LDA, 0 ]MBUF STA,               
    0D1 CALL-MLI     ( GET_EOF )        
    4 ]MBUF LDA,     ( hi must be 0 )   
    0= NOT IF, # 5 LDX, DIE JSR, THEN,  
     \ save len in variable             
    2 ]MBUF LDA, FLEN STA,              
    3 ]MBUF LDA, FLEN 1+ STA,           
                                        
DECIMAL -->                    ( 13:22) 
════════════════════════════════════════   SCREEN 075
(                        < 2/ 3/87>215) 
HEX                                     
\ Now lets read the file                
  # 4 LDA, 0 ]MBUF STA,                 
  REF# LDA, 1 ]MBUF STA,                
   \ Read in starting at $800           
  # 0 LDA, 2 ]MBUF STA,                 
  # 8 LDA, 3 ]MBUF STA,                 
   \ is File less $1800 bytes?          
  FLEN 1+ LDA, # 18 CMP, 0<             
  IF, \ yes, read entire file           
   \ starting at $800                   
   FLEN LDA, 4 ]MBUF STA,               
   FLEN 1+ LDA, 5 ]MBUF STA,            
   READ JSR,                            
  ELSE,                                 
   \ Read in the first part             
   \ then read in the second part       
   \ starting at the load address       
   \ in the AUX_TYPE field              
                                        
DECIMAL -->                             
                                        
                               ( 13:22) 
════════════════════════════════════════   SCREEN 076
(                        < 2/ 3/87>216) 
                                        
\ file in two parts,                    
\ read the first part                   
   # 00 LDA, 4 ]MBUF STA,               
   # 18 LDA, 5 ]MBUF STA,               
   READ JSR,                            
    \ set 2nd load address              
   FAUX LDA, 2 ]MBUF STA,               
   FAUX 1+ LDA, 3 ]MBUF STA,            
   FLEN LDA, 4 ]MBUF STA,               
   \ compute remaining length           
   FLEN 1+ LDA, SEC, # 18 SBC,          
   5 ]MBUF STA,                         
   READ JSR,                            
  THEN,                                 
\ *** !FILE IS NOW IN MEMORY! ***       
                                        
  800 JMP, \ start it up!               
                                        
?CSP FORTH                              
                                        
-->                                     
                               ( 13:22) 
════════════════════════════════════════   SCREEN 077
( SAVE-LOADER            < 2/ 3/87>217) 
                                        
\ this command will write out           
\ the loader to disk under the name     
\ specified                             
                                        
: SAVE-LOADER                           
   BL WORD DUP C@ DUP 15 > SWAP 0= OR   
   ABORT" BAD FILE NAME" >R             
   PLOADER BSA !           \ address    
   HERE PLOADER - 1+ BSL ! \ len        
   8192 BSAUX !            \ AUX_TYPE   
   ?CANMAKE                \ ROOM?      
   R> 255 MAKE-FCB         \ SYS        
   !FILE                   \ !FILE      
   CLOSE-FILE ;                         
                                        
CR CR                                   
." USE WRITE-LOADER TO SAVE" CR         
." FORGET LOADER TO REMOVE" CR CR CR    
                                        
                                        
                                        
                               ( 13:22) 
════════════════════════════════════════   SCREEN 130
(                        <10/ 5/83>270) 
                                        
                                        
: MYRESET                               
  R1-W1 <ABORT> ;                       
                                        
' MYRESET CFA ' BRK-RETN !              
                                        
                                        
                                        
                                        
                                        
                                        
                                        
                                        
                                        
                                        
                                        
                                        
                                        
                                        
                                        
                                        
                               ( 13:22) 
